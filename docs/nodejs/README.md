# Node.js

## 模块

### events

EventEmitter 就是一个发布订阅模式的案例，它是 node 中许多模块的基础。

```javascript
class EventEmitter {
  map = {}
  on(event, cb) {
    if (!this.map[event]) this.map[event] = []
    this.map[event].push(cb)
  }
  emit(event, ...args) {
    for (let cb of this.map[event]) {
      cb.apply(this, args)
    }
  }
}
```

### stream

stream 模块继承自 EventEmitter，分为 readable，writable，duplex，transform。

### fs

学会了 createReadStream 和 createWriteStream 的用法，分别返回一个可读和可写的流。

### Buffer

一个对象，类似数组，元素是 2 位 16 进制，即一个字节

## 异步 I/O

首先 node 中的调用顺序是: node 核心模块 -> c++内建模块 -> 通过 libuv 根据不同平台进行系统调用

当我们发起异步调用的时候, 会根据之前的调用顺序, 走到 libuv 这个封装层, 在这层上会创建一个请求对象, 并且我们在 javascript 层中传入的参数和回调函数也会被挂在这个对象上, 之后这个对象会被推入线程池中等待执行, 这是第一部分.
第二部分是回调通知部分, 线程池中的I/O操作调用完毕后, 会将结果挂在请求对象上, 然后通知系统操作完成, 并将线程归还线程池. 事件循环的每个Tick中会从线程池中取出完成的请求对象, 并将该对象推入I/O观察者队列中, 然后事件循环会不断从观察者队列中取出请求对象, 根据请求结果执行其中的回调函数, 这就完成了一次回调.


## 内存控制

### 内存分配

node中的内存可以分为两个部分, 堆内存和堆外内存, 堆内存是由V8引擎分配, 大小存在限制, 64位系统下大概为1.4GB, 但可以通过相关选项来调整内存限制的大小; 堆外内存则由node直接分配, 虽然node不对它进行大小的限制, 但仍然存在物理限制. 对于开发者来说, 我们增加的变量和对象都存放在堆内存中, 想要使用堆外内存, 只能通过Buffer对象.

### 垃圾回收

一般来说, 当我们提到垃圾回收, 指的都是V8的垃圾回收系统. V8的垃圾回收主要基于分代式垃圾回收机制, 它将堆内存划分为两块, 分别是新生代和老生代, 新生代采用cheney算法, 将内存块分成两个空间, 分别称为From空间和To空间, 我们新建的变量会存入From空间, 然后当回收触发时, 会将From中的活跃对象复制进To中, 然后清空From, 再把To和From互换身份.
当某个对象已经被转移过了之后, 当下一次垃圾回收触发时, 它会被送入老生代内存区, 这被称为晋升, 另外, 当To的大小占用达到25%时, From中正在转移的活跃对象也会被直接放入老生代内存区.
老生代内存区中主要使用mark-sweep和mark-compact算法, 二者都会标记那些不用的对象, 前者会对这些对象进行清除, 但会产生内存碎片, 而后者则会在清除的同时, 将剩下的对象往前移动, 避免产生碎片, 但因为每次都伴随移动, 所以效率比前者差. 因此, 一般在新生代往老生代内转移的时候发现没有足够的内存时, 使用标记整理算法, 来达到最佳性能. 
由于标记也需要消耗时间, 所以V8采用增量标记和延迟清理以及增量式整理进行优化.

### 内存泄漏

内存泄漏的本质就是应该被清理的对象没有被及时清理, 被转移进了老生代内存区.