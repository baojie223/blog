<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.35">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <title>浏览器工作原理 | 前端成长之路</title><meta name="description" content="构建知识体系，并分类整理对应的技术实现。">
    <link rel="modulepreload" href="/assets/app.5176ced8.js"><link rel="modulepreload" href="/assets/index.html.e4ff7ac2.js"><link rel="modulepreload" href="/assets/index.html.d2f921c3.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper.21dcd24c.js">
    <link rel="stylesheet" href="/assets/style.e8e8fc80.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header ref_key="navbar" class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/" class=""><img class="logo" src="https://vuejs.org/images/logo.png" alt="前端成长之路"><span class="site-name can-hide">前端成长之路</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/summary.md" class="" aria-label="summary"><!--[--><!--]--> summary <!--[--><!--]--></a></div><div class="navbar-item"><a href="/javascript/" class="" aria-label="JavaScript"><!--[--><!--]--> JavaScript <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/summary.md" class="" aria-label="summary"><!--[--><!--]--> summary <!--[--><!--]--></a></div><div class="navbar-item"><a href="/javascript/" class="" aria-label="JavaScript"><!--[--><!--]--> JavaScript <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading">浏览器工作原理 <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/browser/#浏览器架构" class="router-link-active router-link-exact-active sidebar-item" aria-label="浏览器架构"><!--[--><!--]--> 浏览器架构 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/browser/#数据传输" class="router-link-active router-link-exact-active sidebar-item" aria-label="数据传输"><!--[--><!--]--> 数据传输 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/browser/#从输入-url-到页面展示-中间发生了什么" class="router-link-active router-link-exact-active sidebar-item" aria-label="从输入 URL 到页面展示, 中间发生了什么?"><!--[--><!--]--> 从输入 URL 到页面展示, 中间发生了什么? <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/browser/#浏览器安全" class="router-link-active router-link-exact-active sidebar-item" aria-label="浏览器安全"><!--[--><!--]--> 浏览器安全 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/browser/#xmlhttprequest" class="router-link-active router-link-exact-active sidebar-item" aria-label="XMLHttpRequest"><!--[--><!--]--> XMLHttpRequest <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/browser/#宏任务和微任务" class="router-link-active router-link-exact-active sidebar-item" aria-label="宏任务和微任务"><!--[--><!--]--> 宏任务和微任务 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/browser/#promise" class="router-link-active router-link-exact-active sidebar-item" aria-label="Promise"><!--[--><!--]--> Promise <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="浏览器工作原理" tabindex="-1"><a class="header-anchor" href="#浏览器工作原理" aria-hidden="true">#</a> 浏览器工作原理</h1><h2 id="浏览器架构" tabindex="-1"><a class="header-anchor" href="#浏览器架构" aria-hidden="true">#</a> 浏览器架构</h2><p>浏览器早期都是单进程架构, 导致的问题是不稳定, 不流畅, 不安全, 后来 chrome 开启了多进程架构时代, 中间也经过了多次迭代, 目前是面向服务架构, 由浏览器主进程, 各种服务进程(GPU 进程, 网络进程, 文件进程等), 每个页面单独的渲染进程(对于同一站点, 即协议与根域名相同的站点, chrome 会复用渲染进程), 插件进程, 共同构成.</p><p>各页面渲染进程的独立使得页面脚本的执行互不干扰, 解决了不稳定不流畅的问题, 同时各个进程是在沙箱中运行的, 也更安全了.</p><h2 id="数据传输" tabindex="-1"><a class="header-anchor" href="#数据传输" aria-hidden="true">#</a> 数据传输</h2><p>网络层的 IP 协议负责把数据包送到目标主机, 传输层的 TCP/UDP 协议负责把数据包送到目标应用端口, 其中 TCP 协议通过三次握手, 传输数据, 四次挥手保证了数据稳定性.</p><p>浏览器多个标签均发起请求时, 源端口是相同的, 但网络进程知道每个 TCP 连接对应的标签, 所以接收到数据后, 会将内容分发到目标标签页的渲染进程.</p><h2 id="从输入-url-到页面展示-中间发生了什么" tabindex="-1"><a class="header-anchor" href="#从输入-url-到页面展示-中间发生了什么" aria-hidden="true">#</a> 从输入 URL 到页面展示, 中间发生了什么?</h2><p>这个问题我用 chrome 浏览器的行为来描述一下.</p><ol><li><p>浏览器地址栏判断输入的内容是否符合 URL 规则, 如果不符合, 会使用默认的搜索引擎合成带搜索关键字的 URL, 如果符合, 会加上协议, 把它合成为完整的 URL, 同时当前页面也会触发 beforeunload 事件.</p></li><li><p>接下来就进入页面资源请求阶段, 浏览器进程会通过 IPC 将 URL 请求发送至网络进程中, 由网络进程发起真正的请求. 首先网络进程会查找本地缓存, 如果找到了缓存资源就直接返回给浏览器进程, 没有找到则进入网络请求流程.网络请求的第一步是 DNS 解析, 获取服务器 IP 地址, 如果是 HTTPS 协议, 则还要建立 TLS 连接. 接着就是利用 IP 地址建立 TCP 连接, 建立完成后浏览器会构建请求行和请求头, 并带上和该域名相关的 Cookie, 发送给服务器. 服务器接收到请求消息后, 生成响应数据发送给浏览器的网络进程. 网络进程在接收到响应行和响应头后, 就开始解析.</p></li></ol><p>如果返回的状态码是 301 或者 302, 代表服务器要浏览器重定向到别的 URL, 则网络进程会读取响应头中的 Location 字段获取重定向的地址, 然后重新开始页面资源请求.</p><p>如果返回的是 200, 浏览器会根据 Content-Type 字段决定如何显示响应体的内容, 假如该字段被浏览器判断为下载类型, 那么这次请求会被提交到浏览器的下载管理器, 如果是 HTML, 浏览器进程会向渲染进程发起&quot;提交文档&quot;的消息.</p><ol start="3"><li><p>chrome 会为每个页面分配一个渲染进程. 唯一的例外就是当从 A 网站内部打开 B 网站时, 如果是同一站点(即协议与根域名相同), 则会复用之前的渲染进程.</p></li><li><p>渲染进程接收到&quot;提交文档&quot;的信息后, 会和网络进程建立传输数据的管道, 等文档数据传输完成后, 渲染进程会返回&quot;确认提交&quot;的信息给浏览器进程, 浏览器进程收到消息后, 会更新浏览器界面状态, 导航流程就结束了, 进入下一步渲染阶段.</p></li><li><p>渲染阶段的处理流程叫做渲染流水线, 包括了多个子阶段.</p></li></ol><p>构建 DOM 树</p><p>样式计算, 会把所有的 CSS 样式, 包括 link 中的外部文件, style 标签, 元素的 style 属性, 转换成 styleSheets, 并且对其中的属性值进行标准化操作, 然后计算每个节点的样式, 根据 CSS 继承和层叠的特性, 将每个节点的最终样式保存在 ComputedStyle 的结构内.</p><p>布局, 计算出 DOM 树中可见元素的几何位置, 分为两个步骤, 构建布局树和布局计算, 构建布局树会忽略掉所有不可见的元素.</p><p>分层, 当元素有了层叠上下文属性或者需要被裁剪</p><h2 id="浏览器安全" tabindex="-1"><a class="header-anchor" href="#浏览器安全" aria-hidden="true">#</a> 浏览器安全</h2><ol><li>跨站脚本攻击（XSS）</li></ol><ul><li>类型：存储型、反射性、DOM 型</li><li>防范策略： <ul><li>服务器对输入的内容进行过滤或转码</li><li>使用 CSP（内容安全策略）：通过 Content-Security-Policy 字段开启，可以做到只执行白名单中的脚本</li><li>使用 HttpOnly 保护重要的 Cookie</li></ul></li></ul><ol start="2"><li>跨站请求伪造（CSRF）</li></ol><h2 id="xmlhttprequest" tabindex="-1"><a class="header-anchor" href="#xmlhttprequest" aria-hidden="true">#</a> XMLHttpRequest</h2><ol><li><p>使用 xhr 封装一个请求函数</p></li><li><p>跨域问题</p></li></ol><ul><li>产生的原因: 浏览器的同源策略(协议, 域名, 端口均相同即为同源)</li></ul><h2 id="宏任务和微任务" tabindex="-1"><a class="header-anchor" href="#宏任务和微任务" aria-hidden="true">#</a> 宏任务和微任务</h2><ol><li>宏任务和微任务分别是什么?</li></ol><p>页面中的大部分任务都是在浏览器主线程中执行的, 为了让这些任务有序执行, 就引入了事件循环和消息队列的机制, 渲染进程内部维护一个或多个消息队列, 比如延迟消息队列和普通消息队列, 然后主线程不断地从队列中取出任务并执行, 这些在消息队列中的任务就是宏任务.</p><p>每个宏任务都会有一个自己的微任务队列, 每当宏任务执行结束时, 会依次执行微任务队列中的任务, 如果在执行微任务的时候产生了新的微任务, 也会继续推入这个队列中, 而微任务由两种方式生成, 一种是 Promise 的 resolve 和 reject, 另一种是 MutationObserver 监控的 DOM 节点发生变化.</p><ol start="2"><li>微任务产生的原因?</li></ol><p>宏任务的时间粒度比较大, 不能精确控制执行的时间间隔, 无法满足高实时性的需求, 比如监听 DOM 的变化.</p><h2 id="promise" tabindex="-1"><a class="header-anchor" href="#promise" aria-hidden="true">#</a> Promise</h2><ol><li>如何实现一个 Promise?</li></ol><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: baojiedashuaibi@gmail.com">jerry23</span><!--[-->, <!--]--><!--]--><!--[--><span class="contributor" title="email: baojie223@qq.com">baojie</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/assets/app.5176ced8.js" defer></script>
  </body>
</html>
